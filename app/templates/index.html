{% extends "base.html" %}
{% import 'bootstrap/wtf.html' as wtf %}
{% block app_content %}
<div class="container">
  <div class="row">
    {% if conn_open %}
    <div class="col bg-success">The connection is established.</div>
    {{ wtf.quick_form(dform, id="stop", action="/stop") }}
    {% else %}
    <div class="col bg-warning">The connection is closed.</div>
    <div class="col">You can configure it <a href="{{ url_for('config') }}" class="text-warning">here.</a></div>
    {% endif %}
  </div>
</div>

<p>Average ping/pong latency: <b><span id="ping-pong"></span>ms</b></p>
<h2>Messages:</h2>
<div id="log"></div>
<h2>Data:</h2>
<div id="plot"><!-- Plotly chart will be drawn inside this DIV --></div>
<table class="table" id ="ard_log">
  <thead>
  <tr>
    <th>#</th>
    <th>Date</th>
    <th>Setpoint</th>
    <th>Input</th>
    <th>Error</th>
    <th>Output</th>
  </tr>
</thead>
<tbody> </tbody>
</table>
{% endblock %}

{% block scripts %}
{{super()}}
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script type="text/javascript" src="//code.jquery.com/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
<script type="text/javascript" charset="utf-8">
$(document).ready(function() {
  namespace = '';
  // Connect to the Socket.IO server.
  // The connection URL has the following format:
  //     http[s]://<domain>:<port>[/<namespace>]
  var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port + namespace);
  // Event handler for new connections.
  socket.on('connect', function() {
    socket.emit('my_response', {data: 'I\'m connected!'});
  });

  // Event handler for server sent data.
  socket.on('my_response', function(msg) {
    $('#log').prepend('<br>' + $('<div/>').text('Received #' + msg.count + ': ' + msg.data).html());
  });

  // Event handler for server sent data.
  socket.on('log_response', function(msg) {
    var count = msg.count;
    var data = msg.data;
    var time = msg.time;

    var ard_log_str = '<tr>'
    ard_log_str = ard_log_str + '<td>' + msg.count +'</td>';
    ard_log_str = ard_log_str + '<td>' + msg.time +'</td>';
    for (var i=0; i<data.length; i++){
        ard_log_str = ard_log_str + '<td>' + data[i] +'</td>';
    }
    ard_log_str = ard_log_str + '</tr>'

      $('#ard_log > tbody').prepend(ard_log_str).html()

    Plotly.extendTraces('plot', {
      x:[[time], [time], [time]],
      y:[[data[0]], [data[1]], [data[3]]]
    }, [0,1,2])
  });

  // Interval function that tests message latency by sending a "ping"
  var ping_pong_times = [];
  var start_time;
  window.setInterval(function() {
    start_time = (new Date).getTime();
    socket.emit('my_ping');
  }, 1000);
  // Handler for the "pong" message. When the pong is received, the
  // time from the ping is stored, and the average of the last 30
  // samples is average and displayed.
  socket.on('my_pong', function() {
    var latency = (new Date).getTime() - start_time;
    ping_pong_times.push(latency);
    ping_pong_times = ping_pong_times.slice(-30); // keep last 30 samples
    var sum = 0;
    for (var i = 0; i < ping_pong_times.length; i++)
    sum += ping_pong_times[i];
    $('#ping-pong').text(Math.round(10 * sum / ping_pong_times.length) / 10);
  });
});

var setpoint_trace = {
  x: [],
  y: [],
  name: 'Setpoint',
  type: 'scatter'
};

var input_trace = {
  x: [],
  y: [],
  name: 'Measured T',
  type: 'scatter'
};

var control_trace = {
  x: [],
  y: [],
  name: 'Control',
  type: 'scatter'
};

var data = [ setpoint_trace, input_trace, control_trace];
var layout = {};

Plotly.newPlot('plot', data, layout);
</script>
{% endblock %}
